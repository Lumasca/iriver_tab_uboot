/********************************************************************
 *  2010.10 jhlim
 *  mx100 main
*   copyright(c) iriver.inc
*   
 *********************************************************************/
#include "mx100_inc.h"
 #include <stdarg.h>
#include <common.h>

#ifdef DISPLAY_BOOTLOGO
#include "mx100_bitmap.c"
#include "mx100_bitmap.h"
#endif 


int g_user_emergency_mode = _EMERGENCY_NONE;

unsigned char g_surface[32];

void init_mx100_ui(unsigned char* fb_buffer)
{
	extern void LCD_turnon(void);

	gfx_prepare_bitmap(pImg_BATTERY_BG);
	gfx_prepare_bitmap(pImg_BOOTING_LOGO);
	gfx_prepare_bitmap(pImg_CHARGE_0);
	gfx_prepare_bitmap(pImg_CHARGE_1);
	gfx_prepare_bitmap(pImg_CHARGE_2);
	gfx_prepare_bitmap( pImg_CHARGE_3);
	gfx_prepare_bitmap( pImg_LOOP_01);
	gfx_prepare_bitmap( pImg_LOOP_02);
	gfx_prepare_bitmap( pImg_LOOP_03);
	gfx_prepare_bitmap( pImg_LOOP_04);
	gfx_prepare_bitmap (pImg_LOOP_05);
	gfx_prepare_bitmap (pImg_TURN_OFF_02_KOR);
	gfx_prepare_bitmap (pImg_TURN_OFF_03_KOR);

	gfx_init_gdi(g_surface,fb_buffer,MX100_LCD_WIDTH,MX100_LCD_HEIGHT,GFX_BPP_32);

	memset(CFG_LCD_FBUFFER,0x0,MX100_LCD_WIDTH * MX100_LCD_HEIGHT * 4);
	#if 0
	gfx_draw_fill_rect(  g_surface,
                           0,
                           0,
                           MX100_LCD_WIDTH,
                           MX100_LCD_HEIGHT,

                           GFX_RGB32(0x0,0x0,0x0)
                           );                          	
        #endif
}


unsigned char g_surface[32];

#include "version_autogenerated.h"
const char version_string1[] =
	U_BOOT_VERSION" (" __DATE__ " - " __TIME__ ")"CONFIG_IDENT_STRING;
char boot_menu_version[64] ="VER." __DATE__ "-" __TIME__;


void draw_uboot_version(void)
{
	unsigned int ColorSet[3] = { GFX_RGB32(0xff,0xff,0xff),GFX_RGB32(0xdd,0xdd,0xdd),GFX_RGB32(0x0,0x0,0x0) };

	gfx_draw_string(
			g_surface,
			(void*)version_string1,
	              10,
	              10,
	              TF_SHADE | TF_TRANSPARENT,
	              0,
	              ColorSet	);
}

void draw_mx100_version(void)
{
	unsigned int ColorSet[3] = { GFX_RGB32(0xff,0xff,0xff),GFX_RGB32(0xdd,0xdd,0xdd),GFX_RGB32(0x0,0x0,0x0) };
	extern int movi_boot_src();
	char mx100_version[32];
	sprintf(mx100_version,"%s %s","SD BOOT",boot_menu_version);

	if(mx100_boot_from()==BOOT_MMCSD) {
		gfx_draw_string(
				g_surface,
				mx100_version,
		              10,
		              10,
		              TF_SHADE,
		              0,
		              ColorSet	);

	}  else {
		sprintf(mx100_version,"%s",MX100_VERSION);
	}

	printf("%s\n",mx100_version);
	
}

void draw_bootlogo(void)
{
	#ifdef DISPLAY_BOOTLOGO	
   	PWM_UserSelect(70); 
	
	gfx_draw_bitmap(g_surface,
                      410, //int iLeft,
                     150, //int iTop,
                     (unsigned char*) pImg_BOOTING_LOGO,
                      0, //int iSourceLeft,
                      0, //int iSourceTop,
                       0,//int iSourceCopydWidth,
                      0,// int iSourceCopydHeight,
                      GFX_ROP_COPY //int iRop
                       );	
	#endif
}



int g_cur_text_x_org = 0;
int g_cur_text_x = 0;
int g_cur_text_y = 0;

void set_text_display_pos(int x,int y)
{
	g_cur_text_x_org = x;
	g_cur_text_x = x;
	 g_cur_text_y = y;
}

void display_text(int newline,int ColorType,char *fmt,...)
{
	int size;
	int string_gfx_width;
	
	unsigned int ColorSet[] = { GFX_RGB32(0xff,0xff,0xff),GFX_RGB32(0xdd,0xdd,0xdd),GFX_RGB32(0x0,0x0,0x0) ,
						  GFX_RGB32(0x0,0x0,0xff0),GFX_RGB32(0x0,0x0,0xdd),GFX_RGB32(0x0,0x0,0x0), 
						GFX_RGB32(0xff,0x0,0x0),GFX_RGB32(0xdd,0x0,0x0),GFX_RGB32(0x0,0x0,0x0) };

	va_list args;
	unsigned int i;
	char printbuffer[128];

	va_start (args, fmt);

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vsprintf (printbuffer, fmt, args);
	va_end (args);

	size = strlen(printbuffer);


	
	string_gfx_width=gfx_draw_string(
			g_surface,
			printbuffer,
	              g_cur_text_x,
	              g_cur_text_y,
	              TF_SHADE | TF_TRANSPARENT,
	              0,
	              &ColorSet[ColorType * 3]	);


	if(newline) {
		g_cur_text_y+= 20;
		g_cur_text_x = g_cur_text_x_org;
	} else {
		g_cur_text_x += string_gfx_width;
	}
	
	printf(printbuffer);
}
#ifdef DISPLAY_BOARD_INFO


#define MAX_BOARD_INFO_LINE (20)

char g_board_info_string[MAX_BOARD_INFO_LINE * 30];

 char *g_board_info_line[MAX_BOARD_INFO_LINE];

int g_board_info_line_count = 0;

int g_board_info_string_offset = 0;

void add_board_info(int newline,char *fmt, ...)
{
	int size;

	va_list args;
	unsigned int i;
	char printbuffer[128];

	va_start (args, fmt);

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vsprintf (printbuffer, fmt, args);
	va_end (args);

	size = strlen(printbuffer);

	if(newline) {
		strcpy(&g_board_info_string[g_board_info_string_offset],printbuffer);

		g_board_info_line[g_board_info_line_count] =  &g_board_info_string[g_board_info_string_offset];

		g_board_info_string_offset += (size + 1);

		g_board_info_line_count++;
	} else {
		strcat(&g_board_info_string[g_board_info_string_offset],printbuffer);
		g_board_info_string_offset += size;
	}
}

char *get_board_info_string(int line)
{
	if(line < g_board_info_line_count) {
		return g_board_info_line[line];
	} else {
		return 0;
	}
}

void display_board_info(int x,int y)
{
	int i;
	unsigned int ColorSet[3] = { GFX_RGB32(0xff,0xff,0xff),GFX_RGB32(0xdd,0xdd,0xdd),GFX_RGB32(0x0,0x0,0x0) };

	for(i=0;i<g_board_info_line_count;i++) {
		gfx_draw_string(
				g_surface,
				get_board_info_string(i),
		              x+10,
		              y+20 * i,
		              TF_SHADE | TF_TRANSPARENT,
		              0,
		              ColorSet	);
	}
}

#endif


void mx100_gpio_preset(void)
{
    // mute	
	GPIO_SetFunctionEach(U_GPIO_EARJACK_MUTE_OUT, eGPO);	
	GPIO_SetPullUpDownEach(U_GPIO_EARJACK_MUTE_OUT ,eGPDen);
	GPIO_SetDataEach(U_GPIO_EARJACK_MUTE_OUT,0);

    
#if (MX100_HW_VER >= MX100_WS)
    // charger ic 
	GPIO_SetFunctionEach(U_GPIO_FULL_BATT_REQ_IN, eGPI);	
	GPIO_SetPullUpDownEach(U_GPIO_FULL_BATT_REQ_IN ,eGPUDdis);
    
	GPIO_SetFunctionEach(U_GPIO_DC_APT_DETECT_IN, eGPI);	
	GPIO_SetPullUpDownEach(U_GPIO_DC_APT_DETECT_IN ,eGPUDdis);

	GPIO_SetFunctionEach(U_GPIO_USB_INSERT_IN, eGPI);	
	GPIO_SetPullUpDownEach(U_GPIO_USB_INSERT_IN ,eGPUDdis);

    
    /* ktj add 2011-01-30 */
	GPIO_SetFunctionEach(eGPIO_C0, eGPIO_3, 1);	
  	    GPIO_SetDataEach(eGPIO_C0, eGPIO_3, 1);
	GPIO_SetFunctionEach(eGPIO_C0, eGPIO_4, 1);	
  	    GPIO_SetDataEach(eGPIO_C0, eGPIO_4, 1);

	GPIO_SetFunctionEach(eGPIO_D1, eGPIO_0, 1);	
  	    GPIO_SetDataEach(eGPIO_D1, eGPIO_0, 1);
	GPIO_SetFunctionEach(eGPIO_D1, eGPIO_1, 1);	
  	    GPIO_SetDataEach(eGPIO_D1, eGPIO_1, 1);
	GPIO_SetFunctionEach(eGPIO_D1, eGPIO_2, 1);	
  	    GPIO_SetDataEach(eGPIO_D1, eGPIO_2, 1);
	GPIO_SetFunctionEach(eGPIO_D1, eGPIO_3, 1);	
  	    GPIO_SetDataEach(eGPIO_D1, eGPIO_3, 1);
	GPIO_SetFunctionEach(eGPIO_D1, eGPIO_4, 1);	
  	    GPIO_SetDataEach(eGPIO_D1, eGPIO_4, 1);
	GPIO_SetFunctionEach(eGPIO_D1, eGPIO_5, 1);	
  	    GPIO_SetDataEach(eGPIO_D1, eGPIO_5, 1);

	GPIO_SetFunctionEach(eGPIO_J1, eGPIO_3, 1);	
  	    GPIO_SetDataEach(eGPIO_J1, eGPIO_3, 1);
    GPIO_SetFunctionEach(eGPIO_J1, eGPIO_4, 1);	
  	    GPIO_SetDataEach(eGPIO_J1, eGPIO_4, 1);

	GPIO_SetFunctionEach(eGPIO_J2, eGPIO_6, 1);	
  	    GPIO_SetDataEach(eGPIO_J2, eGPIO_6, 1);
	GPIO_SetFunctionEach(eGPIO_J2, eGPIO_7, 1);	
  	    GPIO_SetDataEach(eGPIO_J2, eGPIO_7, 1);

	GPIO_SetFunctionEach(eGPIO_C0, eGPIO_3, 1);	
  	    GPIO_SetDataEach(eGPIO_C0, eGPIO_3, 1);

	GPIO_SetFunctionEach(eGPIO_J3, eGPIO_0, 1);	
  	    GPIO_SetDataEach(eGPIO_J3, eGPIO_0, 1);
	GPIO_SetFunctionEach(eGPIO_J3, eGPIO_1, 1);	
  	    GPIO_SetDataEach(eGPIO_J3, eGPIO_1, 1);
	GPIO_SetFunctionEach(eGPIO_J3, eGPIO_4, 1);	
  	    GPIO_SetDataEach(eGPIO_J3, eGPIO_4, 1);
	GPIO_SetFunctionEach(eGPIO_J3, eGPIO_5, 1);	
  	    GPIO_SetDataEach(eGPIO_J3, eGPIO_5, 1);
	GPIO_SetFunctionEach(eGPIO_J3, eGPIO_6, 1);	
  	    GPIO_SetDataEach(eGPIO_J3, eGPIO_6, 1);
	GPIO_SetFunctionEach(eGPIO_J3, eGPIO_7, 1);	
  	    GPIO_SetDataEach(eGPIO_J3, eGPIO_7, 1);

	GPIO_SetFunctionEach(eGPIO_J4, eGPIO_0, 1);	
  	    GPIO_SetDataEach(eGPIO_J4, eGPIO_0, 1);
	GPIO_SetFunctionEach(eGPIO_J4, eGPIO_1, 1);	
  	    GPIO_SetDataEach(eGPIO_J4, eGPIO_1, 1);
	GPIO_SetFunctionEach(eGPIO_J4, eGPIO_2, 1);	
  	    GPIO_SetDataEach(eGPIO_J4, eGPIO_2, 1);
	GPIO_SetFunctionEach(eGPIO_J4, eGPIO_3, 1);	
  	    GPIO_SetDataEach(eGPIO_J4, eGPIO_3, 1);
  	    
//#if defined(MX100_REV_TP) /* ktj */
        GPIO_SetDataEach(eGPIO_C0, eGPIO_3, 0); // UART_AN_SW set low 
//#endif  	    
#endif
}

//
// system boot menu impl.
// 

#define MENU_VERSION_INFO "Board info"
#define MENU_FASTBOOT_FULL "Fastboot Full"
#define MENU_FASTBOOT "Fastboot"
#ifdef ENABLE_FASTBOOT_ON_BOOT
#define MENU_FASTBOOT_ON_BOOT  "Fastboot On BOOT"
#endif

#define MENU_PERI_TEST "Peri test"
#define MENU_MPSD_COPY "MP FWUP from SD(eng)"
#define MENU_USER_FWUP "MP FWUP from SD(user)"
#define MENU_SD_FWUP "FWUP from SD(user)"

#define MENU_EMERGENCY_FW_UPGRADE "Emergency F/W upgrade"
#define MENU_SAY_RCVBOOT "Boot Into SH Recovery"

#ifdef ENABLE_SELECT_MP_MODE 
#define MENU_SELECT_MP_MODE  "MP mode"
#endif

#ifdef ENABLE_INITIALIZE_DATA
#define MENU_RESET_DATA  "MP Initialize Data"
#endif
#ifdef ENABLE_BUNDLE_IMG_COPY
#define MENU_BUNDLE_IMG_COPY "Bundle Contents Copy from SD"
#endif

#define MENU_TOUCH_UPDATE "Melfas Touch Fw update"
#define MENU_TOUCH_DELAY_TEST "Touch Delay Test"
#define MENU_ENABLE_SERIAL_DEBUG "Enable Serial Debug"
#define MENU_ENABLE_CDMA_PCLINK "Enable CDMA PC Link"
#define MENU_NO_STOP_BOOT  "Charge On BOOT"

#ifdef ENABLE_SYSTEM_LOG
#define MENU_ENABLE_SYSTEM_LOG "Enable system log"
#endif

#define MENU_ENABLE_OLD_8000_TS  "Old melfas 8000 ts"

#define MENU_BOOT_ANDROID "Boot mx100"
#define MENU_POWER_OFF "Power OFF"
#define MENU_TEST_FUNCTION  "code test"

#ifdef ENABLE_BOOT_MODE_SELECT
#define MENU_ONENAND_BOOT  "ONENAND boot"
#define MENU_NFS_BOOT  "NFS boot"
#endif

#define MAX_MENU_ITEM (30)

static char *g_menu_str[MAX_MENU_ITEM];

int g_cur_menu = 0;
int g_max_menu=0;

unsigned char g_surface_menu[32];
 unsigned char *g_TempMenuBuffer;
int g_menu_width = 0;
int g_menu_height;

int g_widget_x_pos = 0;

void add_boot_menu(void)
{
	int bootmenu_mode = get_bootmenu_mode();
	
	g_max_menu = 0;

	#if (MP_MODE_DEFAULT == MP_MODE_PROCESS)
	sprintf(boot_menu_version,"MX100 BOOT:MP PROCESS: %s %s", __DATE__,__TIME__ );
	#else
	sprintf(boot_menu_version,"MX100 BOOT:MP NORMAL: %s %s", __DATE__,__TIME__);
	#endif
	
	if(get_bootmenu_mode()==MX100_BOOTMENU_USER_EMERGENCY) { 
		g_menu_str[g_max_menu++] =MENU_BOOT_ANDROID;
		g_menu_str[g_max_menu++] ="---------------------";
		g_menu_str[g_max_menu++] =MENU_POWER_OFF;
		g_menu_str[g_max_menu++] ="---------------------";
		g_menu_str[g_max_menu++] =MENU_EMERGENCY_FW_UPGRADE;
		g_menu_str[g_max_menu++] ="---------------------";	
		g_menu_str[g_max_menu++] =MENU_SAY_RCVBOOT;
		g_menu_str[g_max_menu++] ="---------------------";	
		g_menu_str[g_max_menu++] =MENU_FASTBOOT;
		g_menu_str[g_max_menu++] ="---------------------";	
		g_menu_str[g_max_menu++] ="= SH DEBUG FEATURE =";
		g_menu_str[g_max_menu++] =MENU_ENABLE_SERIAL_DEBUG;
		g_menu_str[g_max_menu++] =MENU_ENABLE_CDMA_PCLINK;
		g_menu_str[g_max_menu++] =MENU_NO_STOP_BOOT;
		g_menu_str[g_max_menu++] =MENU_ENABLE_SYSTEM_LOG;
		g_menu_str[g_max_menu++] = MENU_VERSION_INFO;
	} else {
		g_menu_str[g_max_menu++] =MENU_PERI_TEST;
		g_menu_str[g_max_menu++] = MENU_VERSION_INFO;
		g_menu_str[g_max_menu++] ="---------------------";		
		g_menu_str[g_max_menu++] =MENU_MPSD_COPY;
		g_menu_str[g_max_menu++] =MENU_USER_FWUP;

		if(bootmenu_mode==MX100_BOOTMENU_DEVELOPER){ 
			g_menu_str[g_max_menu++] =MENU_SD_FWUP;

		}
		#ifdef ENABLE_BUNDLE_IMG_COPY
			g_menu_str[g_max_menu++] = MENU_BUNDLE_IMG_COPY;
		#endif

		#ifdef ENABLE_SELECT_MP_MODE 
		if(bootmenu_mode==MX100_BOOTMENU_MP_PROCESS) {
			g_menu_str[g_max_menu++] =MENU_SELECT_MP_MODE;
		}
		#endif

		#ifdef ENABLE_INITIALIZE_DATA
		if(bootmenu_mode==MX100_BOOTMENU_MP_PROCESS) {
			g_menu_str[g_max_menu++] = MENU_RESET_DATA;
		}
		#endif
		g_menu_str[g_max_menu++] ="---------------------";

	//	if(bootmenu_mode == MX100_BOOTMENU_DEVELOPER) 
		{
			g_menu_str[g_max_menu++] =MENU_FASTBOOT_FULL;
			g_menu_str[g_max_menu++] =MENU_FASTBOOT;
		}

		#ifdef ENABLE_MELFAS_FWUP
		g_menu_str[g_max_menu++] ="---------------------";
		g_menu_str[g_max_menu++] =MENU_TOUCH_UPDATE;
		#endif

		if((g_mx100_hw_type !=MX100_ES1) || (g_mx100_hw_type !=MX100_ES1) || (g_mx100_hw_type !=MX100_UNKNOWN)) {
			#ifdef ENABLE_UART2_SELECT
			g_menu_str[g_max_menu++] ="---------------------";
			g_menu_str[g_max_menu++] =MENU_ENABLE_SERIAL_DEBUG;
			#endif

			#ifdef ENABLE_CDMA_PCLINK_SELECT
			g_menu_str[g_max_menu++] =MENU_ENABLE_CDMA_PCLINK;
			#endif
		}

		if(bootmenu_mode == MX100_BOOTMENU_MP_NORMAL) {	
			#ifdef ENABLE_NO_STOP_BOOT
			g_menu_str[g_max_menu++] =MENU_NO_STOP_BOOT;
			#endif
		}

		#ifdef ENABLE_SYSTEM_LOG
			g_menu_str[g_max_menu++] =MENU_ENABLE_SYSTEM_LOG;
		#endif

		if(g_mx100_hw_type ==MX100_TP1) {
			g_menu_str[g_max_menu++] =MENU_ENABLE_OLD_8000_TS;
			g_menu_str[g_max_menu++] ="---------------------";
		}

		g_menu_str[g_max_menu++] =MENU_BOOT_ANDROID;
		g_menu_str[g_max_menu++] =MENU_POWER_OFF;
	}

};

void init_menu(void)
{
	int i;
	int menu_width;

	add_boot_menu();

	for(i = 0; i<g_max_menu;i++) {
		menu_width = gfx_draw_string(
				0,
				g_menu_str[i],
		              0,
		              0,
		              TF_GET_STRING_WIDTH,
		              0,
		              0);
		if(menu_width>g_menu_width) g_menu_width = menu_width;
		
	}
	g_menu_width +=20;
	g_menu_height = g_max_menu * 16 + 20;
	
		gfx_create_bitmap(g_surface_menu,0,g_menu_width,g_menu_height,GFX_BPP_32);

		gfx_draw_fill_rect(  g_surface_menu,
                       0,
                       0,
                       g_menu_width,
                       g_menu_height,

                       GFX_RGB32(0x0,0x0,0x0)
                       );
	g_widget_x_pos = g_menu_width + 50;

}
void clear_screen(void)
{
	gfx_draw_fill_rect(  g_surface,
                           0,
                           0,
                           MX100_LCD_WIDTH,
                           MX100_LCD_HEIGHT,

                           GFX_RGB32(0x0,0x0,0x0)
                           );
	draw_mx100_version	();
}

void press_anykey(void)
{
	unsigned int ColorSet[3] = { GFX_RGB32(0xff,0xff,0xff),GFX_RGB32(0xdd,0xdd,0xdd),GFX_RGB32(0x0,0x0,0x0) };

	gfx_draw_string(
			g_surface,
			"press any key !",
	              400,
	              550,
	              TF_SHADE | TF_TRANSPARENT,
	              0,
	              ColorSet	);
	mx100_get_key();
}

void press_anykey_console(void)
{
	mx100_display_log(LOG_NOR,"press any key !");
	mx100_get_key();
}

void display_menu(void)
{
	int i;
	int y_pos;
	int color_type;
	char menustr[32];
	
	unsigned int ColorSet[] = { GFX_RGB32(0xff,0xff,0xff),GFX_RGB32(0xdd,0xdd,0xdd),GFX_RGB32(0x0,0x0,0x0) ,
						GFX_RGB32(0x0,0x0,0xff),GFX_RGB32(0x0,0x0,0xdd),GFX_RGB32(0x0,0x0,0x0) ,
						  GFX_RGB32(0xff,0x0,0x0),GFX_RGB32(0xdd,0x0,0x0),GFX_RGB32(0x0,0x0,0x0),
						   GFX_RGB32(0x0,0x0,0x0),GFX_RGB32(0x33,0x33,0x33),GFX_RGB32(0xff,0xff,0xff)};

	gfx_draw_fill_rect(  g_surface_menu,
                   0,
                   0,
                   g_menu_width,
                   g_menu_height,

                   GFX_RGB32(0x0,0x0,0x0)
                   );


	for(i=0;i<g_max_menu;i++) {		
		if(i==g_cur_menu) {
			color_type = 3;
			printf("*%d %s\n",i,g_menu_str[i]);
		} else {

			color_type = 0;
			printf(" %d %s\n",i,g_menu_str[i]);

		}
		y_pos = (16 * i) + 10;

		if(color_type ==3) {
			gfx_draw_fill_rect(  g_surface_menu,
	                           8,
	                           y_pos-2,
	                           g_menu_width-18,
	                           16,
	                           GFX_RGB32(0xFF,0xFF,0xFF)
	                           );                          	
		}


		if((int)g_menu_str[i] == (int)MENU_ENABLE_SERIAL_DEBUG) {
			sprintf(menustr,"%s=%s",g_menu_str[i],mx100_get_vars("uart2debug"));
		}
		else if((int)g_menu_str[i] == (int)MENU_ENABLE_CDMA_PCLINK) {
			sprintf(menustr,"%s=%s",g_menu_str[i],mx100_get_vars("cdmalink"));
		} 
		else if((int)g_menu_str[i] == (int)MENU_NO_STOP_BOOT) {
			sprintf(menustr,"%s=%s",g_menu_str[i],mx100_get_vars("bootcharge"));
		} 
		else if((int)g_menu_str[i] == (int)MENU_ENABLE_SYSTEM_LOG) {
			sprintf(menustr,"%s=%s",g_menu_str[i],mx100_get_vars("systemlog"));
		} 	
		else if((int)g_menu_str[i] == (int)MENU_ENABLE_OLD_8000_TS) {
			sprintf(menustr,"%s=%s",g_menu_str[i],mx100_get_vars("old8000ts"));
		} 
		#ifdef ENABLE_SELECT_MP_MODE
		else if((int)g_menu_str[i] == (int)MENU_SELECT_MP_MODE) {
			sprintf(menustr,"%s=%s",g_menu_str[i],mx100_get_vars("mpmode"));
		} 
		#endif
		else {
			strcpy(menustr,g_menu_str[i]);
		}

		gfx_draw_string(
			g_surface_menu,
			menustr,
	              10,
	              y_pos,
	              TF_SHADE,
	              0,
	              &ColorSet[color_type * 3]	);		
	}

	gfx_draw_rect(g_surface_menu,0,0,g_menu_width-1,g_menu_height-1,GFX_RGB32(0xFF,0xFF,0xFF));

	gfx_draw_bitmap(g_surface,
                      30, //int iLeft,
                      100, //int iTop,
                      g_surface_menu,
                      0, //int iSourceLeft,
                      0, //int iSourceTop,
                       0,//int iSourceCopydWidth,
                      0,// int iSourceCopydHeight,
                      GFX_ROP_COPY //int iRop
                       );	
}


//
// mx100 simple widget ui.
//

static struct ts_gfx_msg_box g_msgbox;

static struct ts_gfx_log_view g_logview;
static struct ts_gfx_progressbar g_pgsbar;
static struct ts_gfx_progressbar g_pgsbartotal;

void display_popup_msg(char *fmt, ...)
{
	int i;
	va_list args;
	char printbuffer[256];
	va_start (args, fmt);
	i = vsprintf (printbuffer, fmt, args);
	va_end (args);	

//	gfx_msgbox(&g_msgbox,msg);
	mx100_display_log(LOG_NOR," ");
	mx100_display_log(LOG_NOR,printbuffer);
	mx100_display_log(LOG_NOR," ");
	udelay(1000 * 1000 *2);
}

void mx100_display_log(int type,const char *fmt, ...)
{
	int i;
	
	unsigned int ColorSet[] = { GFX_RGB32(0xff,0xff,0xff),GFX_RGB32(0xdd,0xdd,0xdd),GFX_RGB32(0x0,0x0,0x0) ,
						GFX_RGB32(0x0,0x0,0xff),GFX_RGB32(0x0,0x0,0xdd),GFX_RGB32(0x0,0x0,0x0) ,
						  GFX_RGB32(0xff,0x0,0x0),GFX_RGB32(0xdd,0x0,0x0),GFX_RGB32(0x0,0x0,0x0)};


	va_list args;
	char printbuffer[256];
	va_start (args, fmt);
	i = vsprintf (printbuffer, fmt, args);
	va_end (args);	

	gfx_logview_settext(&g_logview,printbuffer,&ColorSet[type * 3]); 
}

void mx100_set_progress(int percent)
{
	gfx_draw_progressbar(&g_pgsbar,percent);
}

void mx100_set_progress_total(int percent)
{
	gfx_draw_progressbar(&g_pgsbartotal,percent);
}

void init_boot_ui(void)
{
	init_menu();

	clear_screen();

	gfx_init_msgbox(&g_msgbox,
					WIN_WIDTH,		300,
					WIN_HEIGHT,		240,
					MSGBOX_STYLE,	GFX_MSGBOX_CENTER,
					MSGBOX_FLIP_NUM, 3,
					MSGBOX_DELAY, 500,
					GFX_ARGV_END
					);

	gfx_init_logview(&g_logview,
						WIN_X1,g_widget_x_pos,
						WIN_Y1,270,
						WIN_WIDTH,700,
						WIN_HEIGHT,220,
						WIN_TITLE,"log view",
						GFX_ARGV_END);
	gfx_init_progressbar(&g_pgsbar,
						WIN_X1,g_widget_x_pos,
						WIN_Y1,500,
						WIN_WIDTH,700,
						WIN_HEIGHT,30,
						PGS_START,0,
						PGS_END,100,
						PGS_STEP,5,
						WIN_TITLE,"test",
						GFX_ARGV_END);
	gfx_init_progressbar(&g_pgsbartotal,
						WIN_X1,g_widget_x_pos,
						WIN_Y1,540,
						WIN_WIDTH,700,
						WIN_HEIGHT,30,
						PGS_START,0,
						PGS_END,100,
						PGS_STEP,5,
						WIN_TITLE,"test",
						GFX_ARGV_END);
}

void draw_boot_menu_widget(void)
{
	gfx_draw_logview(&g_logview);
	gfx_draw_progressbar(&g_pgsbar,-1);
	gfx_draw_progressbar(&g_pgsbartotal,-1);
}
#ifdef ENABLE_MP_SD_COPY

#define MP_COPY_FWUP_ONLY  (0)
#define MP_COPY_USER_MODE (1)   // added 2011.03.24
#define MP_INITIALIZE_DATA (2)   // added 2011.04.03
#define MP_COPY_ALL (3)

extern int g_mx100_part_num;

void sd_system_copy(int mp_copy_mode)
{
	int ret;
	int retry_count = 0;
	
//	clear_screen();

	printf("MP_COPY_MODE : %d\n",mp_copy_mode);
	
	if(mp_copy_mode == MP_COPY_FWUP_ONLY) {
		display_popup_msg("FW Update from SD selected");
		printf("FW Update from SD selected\n");
	} 
	else if (mp_copy_mode == MP_COPY_USER_MODE) {
		if(get_bootmenu_mode()==MX100_BOOTMENU_USER_EMERGENCY) { 			
			display_popup_msg("start emergency fw update.");
		} else {		
			display_popup_msg("User Mode Update from SD selected");
			printf("User Mode Update from SD selected\n");
		}
	}
	else 	if(mp_copy_mode == MP_COPY_ALL) {
		display_popup_msg("MP SD Copy selected");
		printf("MP SD Copy selected\n");
	}
	retry_count = 0;

	retry_fdisk:	

	if(mp_copy_mode != MP_COPY_FWUP_ONLY) {
		//ret = run_command ("fdisk -c 0",0);
		if(ret==-1) {
			if(retry_count++ > 2) {
				//mx100_display_log(LOG_FAIL," \n error: fdisk !!! \n ");
				//goto mpcopy_fail;
			} else {
				//mx100_display_log(LOG_NOR,"retry %dth",retry_count);
				//goto retry_fdisk;
			}
		}

		//ret = run_command ("fdisk -p 0",0);

              #ifdef USE_VENDOR_PART
		if(g_mx100_part_num != 3) {
                    #else
		if(g_mx100_part_num != 2) {
		#endif
		if(retry_count++ > 2) {
				//mx100_display_log(LOG_FAIL," \n error: verify fdisk !!! \n ");
				//goto mpcopy_fail;
			} else {
				//mx100_display_log(LOG_NOR,"retry %dth",retry_count);
				//goto retry_fdisk;
			}
		}
		
		mx100_set_progress_total(10);
	}
	retry_count=0;
	retry_bootloader:
	ret=run_command("sdfuse flash bootloader u-boot-config_fused.bin",0);
	if(ret==-1) {
		if(retry_count++ > 2) {
			mx100_display_log(LOG_FAIL," \n error: u-boot-config_fused.bin !!! \n ");
			goto mpcopy_fail;
		} else {
			mx100_display_log(LOG_NOR,"Type : %d\n Now Flashing...",retry_count);
			goto retry_bootloader;
		}
	}
	mx100_set_progress_total(20);

	 if (mp_copy_mode == MP_COPY_USER_MODE) {
		retry_count=0;
		retry_boot:
		ret = run_command("sdfuse flash boot boot.img",0);
		if(ret==-1) {
			if(retry_count++ > 2) {
				mx100_display_log(LOG_FAIL," \n error: boot.img !!! \n ");
				goto mpcopy_fail;
			}else {
				mx100_display_log(LOG_NOR,"retry %dth",retry_count);
				goto retry_boot;
			}
		}
		mx100_set_progress_total(40);

	 } else {
		retry_count=0;
		retry_ramdisk_uboot:
		ret = run_command("sdfuse flash ramdisk ramdisk-uboot.img",0);
		if(ret==-1) {
			if(retry_count++ > 2) {
				mx100_display_log(LOG_FAIL," \n error: ramdisk-uboot.img !!! \n ");
				goto mpcopy_fail;
			}else {
				mx100_display_log(LOG_NOR,"retry %dth",retry_count);
				goto retry_ramdisk_uboot;
			}
		}
		mx100_set_progress_total(30);

		retry_count=0;
		retry_zImage:
		ret = run_command("sdfuse flash kernel zImage",0);
		if(ret==-1) {
			if(retry_count++ > 2) {
				mx100_display_log(LOG_FAIL," \n error: zImage !!! \n ");
				goto mpcopy_fail;
			}else {
				mx100_display_log(LOG_NOR,"retry %dth",retry_count);
				goto retry_zImage;
			}
		}
		mx100_set_progress_total(40);
	 }
	 
#if 1 /* ktj add recovery 2011-02-11 */	
	retry_count=0;
	retry_recovery:
	ret = run_command("sdfuse flash recovery recovery.img",0);
	if(ret==-1) {
		if(retry_count++ > 2) {
			mx100_display_log(LOG_FAIL," \n error: recovery.img !!! \n ");
			goto mpcopy_fail;
		}else {
			mx100_display_log(LOG_NOR,"retry %dth",retry_count);
			goto retry_recovery;
		}
	}
	mx100_set_progress_total(45);
#endif

	retry_count=0;
	retry_system:
	ret = run_command("sdfuse flash system system.img",0);
	if(ret==-1) {
		if(retry_count++ > 2) {
			mx100_display_log(LOG_FAIL," \n error:  system.img !!! \n ");
			goto mpcopy_fail;
		}else {
			mx100_display_log(LOG_NOR,"retry %dth",retry_count);
			goto retry_system;
		}
	}
	mx100_set_progress_total(70);

	#if (MP_MODE_DEFAULT == MP_MODE_PROCESS)
	retry_count=0;
	retry_erase_misc:
	ret = run_command ("sdfuse erase misc",0);
	if(ret==-1) {
		if(retry_count++ > 2) {
			mx100_display_log(LOG_FAIL," \n error:  misc!!! \n ");
			goto mpcopy_fail;
		}else {
			mx100_display_log(LOG_NOR,"retry %dth",retry_count);
			goto retry_erase_misc;
		}
	}
	mx100_set_progress_total(75);
	#endif
	
	retry_count=0;

	retry_erase_cache:
	ret = run_command ("sdfuse erase cache",0);
	if(ret==-1) {
		if(retry_count++ > 2) {
			mx100_display_log(LOG_FAIL," \n error:  cache!!! \n ");
			goto mpcopy_fail;
		}else {
			mx100_display_log(LOG_NOR,"retry %dth",retry_count);
			goto retry_erase_cache;
		}
	}
	mx100_set_progress_total(75);

	retry_count=0;
	retry_userdata:
		
	 if (mp_copy_mode == MP_COPY_USER_MODE) {
		ret = run_command ("sdfuse flash userdata userdata.img",0);						
	 } else {
		ret = run_command ("sdfuse erase userdata",0);
	 }
	if(ret==-1) {
		if(retry_count++ > 2) {
			mx100_display_log(LOG_FAIL," \n error:  userdata!!! \n ");
			goto mpcopy_fail;
		}else {
			mx100_display_log(LOG_NOR,"retry %dth",retry_count);
			goto retry_userdata;
		}
	}
	mx100_set_progress_total(80);

	if(mp_copy_mode != MP_COPY_FWUP_ONLY) {

		#ifdef USE_VENDOR_PART
	    /* ktj add vendor 2011-03-23 */	
		retry_count=0;
		retry_erase_vendor:
		//ret = run_command ("sdfuse erase vendor",0);
		if(ret==-1) {
			if(retry_count++ > 2) {
				mx100_display_log(LOG_FAIL," \n error:  vendor!!! \n ");
				goto mpcopy_fail;
			}else {
				mx100_display_log(LOG_NOR,"retry %dth",retry_count);
				goto retry_erase_vendor;
			}
		}
		mx100_set_progress_total(85);
		#endif

		retry_count=0;
		retry_erase_fat:
		//ret = run_command ("sdfuse erase fat",0);
		if(ret==-1) {
			if(retry_count++ > 2) {
				mx100_display_log(LOG_FAIL," \n error:  erase fat!!! \n ");
				goto mpcopy_fail;
			}else {
				mx100_display_log(LOG_NOR,"retry %dth",retry_count);
				goto retry_erase_fat;
			}
		}
	}

	mx100_set_progress_total(100);
	if(get_bootmenu_mode()==MX100_BOOTMENU_USER_EMERGENCY) { 			
		mx100_display_log(LOG_OK,"emergency f/w upgrade completed.\n turn on the mx100.");
	} else {
		mx100_display_log(LOG_OK,"sytem copy completed.\nremove t-flash card. \nturn on the mx100.");
	}

	mx100_get_key();

	do_reset (NULL, 0, 0, NULL);
	return;
	
	mpcopy_fail:
	if(get_bootmenu_mode()==MX100_BOOTMENU_USER_EMERGENCY) { 			
		mx100_display_log(LOG_FAIL," \n emergency f/w upgrade  failed \ncheck f/w upgrade files in t-flash card!!! \n ");
	} else {
		mx100_display_log(LOG_FAIL," \n MP system copy failed \ncheck sd card!!! \n ");

		press_anykey_console();
	}
}
#endif



void mp_initialize_data(int mp_copy_mode)
{
	int ret;
	int retry_count = 0;
	extern int g_mx100_part_num;
	
	clear_screen();
	
	display_popup_msg("MP Initialize Data.");

	retry_count = 0;

	retry_count=0;
	retry_erase_cache:
	ret = run_command ("sdfuse erase cache",0);
	if(ret==-1) {
		if(retry_count++ > 2) {
			mx100_display_log(LOG_FAIL," \n error:  cache!!! \n ");
			goto mpcopy_fail;
		}else {
			mx100_display_log(LOG_NOR,"retry %dth",retry_count);
			goto retry_erase_cache;
		}
	}
	mx100_set_progress_total(75);

	retry_count=0;
	retry_userdata:
		
	 if (mp_copy_mode == MP_COPY_USER_MODE) {
		ret = run_command ("sdfuse flash userdata userdata.img",0);						
	 } else {
		ret = run_command ("sdfuse erase userdata",0);
	 }
	if(ret==-1) {
		if(retry_count++ > 2) {
			mx100_display_log(LOG_FAIL," \n error:  userdata!!! \n ");
			goto mpcopy_fail;
		}else {
			mx100_display_log(LOG_NOR,"retry %dth",retry_count);
			goto retry_userdata;
		}
	}
	mx100_set_progress_total(80);


	#ifdef USE_VENDOR_PART
    /* ktj add vendor 2011-03-23 */	
	retry_count=0;
	retry_erase_vendor:
	//ret = run_command ("sdfuse erase vendor",0);
	if(ret==-1) {
		if(retry_count++ > 2) {
			mx100_display_log(LOG_FAIL," \n error:  vendor!!! \n ");
			goto mpcopy_fail;
		}else {
			mx100_display_log(LOG_NOR,"retry %dth",retry_count);
			goto retry_erase_vendor;
		}
	}
	mx100_set_progress_total(85);
	#endif
	
	retry_count=0;
	retry_erase_fat:
	//ret = run_command ("sdfuse erase fat",0);
	if(ret==-1) {
		if(retry_count++ > 2) {
			mx100_display_log(LOG_FAIL," \n error:  erase fat!!! \n ");
			goto mpcopy_fail;
		}else {
			mx100_display_log(LOG_NOR,"retry %dth",retry_count);
			goto retry_erase_fat;
		}
	}

	mx100_set_progress_total(100);

	mx100_display_log(LOG_OK,"sytem Initialize completed.");

	mx100_set_vars("mpmode","normal");

	press_anykey_console();
	return;
	
	mpcopy_fail:

	mx100_display_log(LOG_FAIL," \n system Initialize failed \ncheck sd card!!! \n ");

	press_anykey_console();
}

#ifdef ENABLE_BUNDLE_IMG_COPY
void sd_bundle_copy(void)
{
	int ret;
	int retry_count = 0;
	extern int g_mx100_part_num;
	
	clear_screen();
	
	display_popup_msg("bundle contents copy");

	retry_count = 0;

	retry_bundle_copy:
	ret = run_command("sdfuse flash fat bundle.img",0);
	if(ret==-1) {
		if(retry_count++ > 2) {
			mx100_display_log(LOG_FAIL," \n error: bundle.img !!! \n ");
			goto mpcopy_fail;
		}else {
			mx100_display_log(LOG_NOR,"retry %dth",retry_count);
			goto retry_bundle_copy;
		}
	}

	return ;
	
	mpcopy_fail:

	mx100_display_log(LOG_FAIL," \n bundle system copy failed \ncheck sd card!!! \n ");

	press_anykey_console();
}
#endif

void mx100_boot_menu(void)
{
	int key;
	int enter_bootmenu = 0;
	
	int i;
	char *mx100_hw_name = get_mx100_hw_name();

	if(g_user_emergency_mode == _EMERGENCY_NONE)
	{
		mx100_check_emergency_mode();
	}

	enter_bootmenu=check_bootmenu_mode();  /* move here. 2011.06.08 JHL */
	
	if(enter_bootmenu == 1)
	{
		char *cur_menu;
//		set_text_display_pos(10,100);
		init_boot_ui();

		draw_boot_menu_widget();

		if(get_bootmenu_mode()==MX100_BOOTMENU_USER_EMERGENCY) { 			
			mx100_display_log(LOG_NOR,"");		
			mx100_display_log(LOG_NOR,"Welcome to irivertab SH bootloader.\n");		
			mx100_display_log(LOG_FAIL,"mx100 hardware typs is %s",mx100_hw_name);	
			mx100_display_log(LOG_NOR,"Choose menu.\n\n");
			mx100_display_log(LOG_FAIL,"If you do emergency fw update, all data will initialize !!!\n");	
		} else {
			mx100_display_log(LOG_NOR,"%s",boot_menu_version);		
			printf("%s\n",boot_menu_version);	
			#ifdef DETECT_MX100_HW
				mx100_display_log(LOG_FAIL,"mx100 hardware typs is %s",mx100_hw_name);
			#endif
			
			mx100_display_log(LOG_NOR,"check your firmware files !!!");		
			mx100_display_log(LOG_NOR,"select menu using up,down,power key!!!\n\n");
		}

		display_menu();
		
		while(1) {

			key = mx100_get_key();

			cur_menu =g_menu_str[ g_cur_menu];
			
			switch(key) {
				case	KEY_POWER: 	
					if((int)cur_menu == (int)MENU_BOOT_ANDROID) {
						run_command ("reset",0);
						goto ExitLoop;
					} 				
					else if((int)cur_menu == (int)MENU_POWER_OFF) {
						clear_screen();
						display_popup_msg("Please wait... POWER OFF...");
						udelay(1000 * 1000);
						power_off();
					}
					else if((int)cur_menu == (int)MENU_SAY_RCVBOOT) {
						clear_screen();
						display_popup_msg(" = Recovery Init Guide by_Say\n1. Press any key to poweroff.\n2. Power on Tab.\n3. Recovery booted.");
						run_command("setenv onenand_boot 'onenand read 30008000 600000 400000; onenand read 30A00000 100000 180000; bootm 30008000 30A00000'",0);
						run_command("setenv bootcmd 'run onenand_boot'",0);
						run_command("save'",0);
						press_anykey();
						udelay(1000 * 1000);
						power_off();
					}
					else if((int)cur_menu == (int)MENU_VERSION_INFO) {
						clear_screen();
						display_board_info(10,100);
						press_anykey();
						clear_screen();
					}
					else if((int)cur_menu == (int)MENU_PERI_TEST) {
						#ifdef ENABLE_DEVICE_TEST
						clear_screen();
						mx100_peri_test();
						press_anykey();
						clear_screen();
						#endif
					}
					else if((int)cur_menu == (int)MENU_FASTBOOT_FULL) {
						clear_screen();
						display_popup_msg("full fastboot mode selected.");
						mx100_display_log(LOG_NOR,"fdisk partiton..");
						//run_command ("fdisk -c 0",0);
						mx100_display_log(LOG_NOR,"enter the fastboot mode..");
						run_command ("fastboot",0);
						press_anykey();
						clear_screen();	
					}				
					else if((int)cur_menu == (int)MENU_FASTBOOT) {
						clear_screen();
						display_popup_msg("fastboot mode selected");
						run_command ("fastboot",0);
						press_anykey();
						clear_screen();	
					}
					#ifdef ENABLE_MP_SD_COPY
					else if((int)cur_menu == (int)MENU_MPSD_COPY) {
						printf("MENU_MPSD_COPY\n");
						sd_system_copy(MP_COPY_ALL);
					}
					else if((int)cur_menu == (int)MENU_SD_FWUP) {
						sd_system_copy(MP_COPY_FWUP_ONLY);
					}
					else if((int)cur_menu == (int)MENU_USER_FWUP || 
						(int)cur_menu == (int)MENU_EMERGENCY_FW_UPGRADE) {
						printf("MENU_USER_FWUP:%d\n",MP_COPY_USER_MODE);
						sd_system_copy(MP_COPY_USER_MODE);
					}
					#ifdef ENABLE_BUNDLE_IMG_COPY
					else if((int)cur_menu == (int)MENU_BUNDLE_IMG_COPY) {
						sd_bundle_copy();
					}
					#endif

					#endif

					#ifdef ENABLE_SELECT_MP_MODE 
					else if((int)cur_menu == (int)MENU_SELECT_MP_MODE) {
						char *vars = mx100_set_vars_toggle("mpmode");				
						display_popup_msg("change MP mode => %s",vars);

					}
					#endif
					#ifdef ENABLE_INITIALIZE_DATA
					else if((int)cur_menu == (int)MENU_RESET_DATA) {
						mp_initialize_data(MP_INITIALIZE_DATA);
						
					}
					#endif

					#ifdef ENABLE_TEST_FUNCTION
					else if((int)cur_menu == (int)MENU_TEST_FUNCTION) {
						clear_screen();
						display_popup_msg("Function Test");

						{
							struct ts_gfx_progressbar l_pgsbar;
							int i;
							
							gfx_init_progressbar(&l_pgsbar,
							WIN_X1,		100,
							WIN_Y1,		520,
							WIN_WIDTH,	600,
							WIN_HEIGHT,	40,
							PGS_START,	0,
							PGS_END,		100,
							PGS_STEP,	1,
							WIN_TITLE,	"test",
							GFX_ARGV_END);		

							gfx_draw_progressbar(&l_pgsbar,-1);
							#if 1
							for(i=0;i<=100;i++) {
								gfx_draw_progressbar(&l_pgsbar,i);
								udelay(100 * 1000);
							}
							#endif
							
						}
						
						if(0){
							struct ts_gfx_log_view l_logview;
							int i;
						
							gfx_init_logview(&l_logview,400,400,300,100,"log view");
							gfx_draw_logview(&l_logview);

							for(i=0;i<=100;i++) {
							
								gfx_logview_settext(&l_logview,"%d test log",0); 

								udelay(1000 * 1000);
							}
						}
						press_anykey_console();
						clear_screen();
					}
					#endif

					#ifdef ENABLE_BOOT_MODE_SELECT	
					
					else if((int)cur_menu == (int)MENU_NFS_BOOT) {
						clear_screen();
						display_popup_msg("Enable NFS Boot");
						run_command("setenv usb_android 'setenv bootargs console=ttySAC2,115200n81 androidboot.console=s3c2410_serial2 init=/init root=/dev/nfs rw nfsroot=192.168.1.1:/root/rootfs/mx100evm/android/ ip=192.168.1.7:192.168.1.1:255.255.255.0::;dnw c0008000;bootm c0008000'",0);
						run_command("setenv bootcmd 'run usb_android'",0);
						run_command("save'",0);
						press_anykey();
						clear_screen();
					}
					
					else if((int)cur_menu == (int)MENU_ONENAND_BOOT) {
						clear_screen();
						display_popup_msg("Enable OneNand Boot");

						run_command("setenv onenand_boot 'onenand read 30008000 600000 400000; onenand read 30A00000 B00000 180000; bootm 30008000 30A00000'",0);
						run_command("setenv bootcmd 'run onenand_boot'",0);
						run_command("save'",0);
						press_anykey();
						clear_screen();
					}
					
					#endif


					#ifdef ENABLE_MELFAS_FWUP
					else if((int)cur_menu == (int)MENU_TOUCH_UPDATE) {
						clear_screen();
						
						display_popup_msg(" \ntouch update selected\n ");
					
						mx100_display_log(LOG_NOR,"start touch update...");
						mx100_set_progress_total(10);

						IRIVER_Touch_Fw_Update();

//						mx100_display_log(LOG_NOR,"completed the touch fw update !!!\n ");
						mx100_set_progress_total(100);

						press_anykey_console();
						clear_screen();
					}


					else if((int)cur_menu == (int)MENU_TOUCH_DELAY_TEST) {
						int IRIVER_Touch_Fw_Up_Test(void);
						clear_screen();
						display_popup_msg("touch delay calibration.");
						IRIVER_Touch_Fw_Up_Test();
						press_anykey();
						clear_screen();
					}
					#endif
					else if((int)cur_menu == (int)MENU_ENABLE_SERIAL_DEBUG) {
//						clear_screen();
						#ifdef DETECT_MX100_HW
						if(g_mx100_hw_type < MX100_TP1) {
							display_popup_msg("not allowed select !!");
						} else 
						#endif
						{
							char *vars = mx100_set_vars_toggle("uart2debug");				
							display_popup_msg("Enable Serial Debug => %s",vars);
							
						}
						//clear_screen();
					}
					else if((int)cur_menu == (int)MENU_ENABLE_CDMA_PCLINK) {
	//					clear_screen();
						#ifdef DETECT_MX100_HW
						if(g_mx100_hw_type < MX100_TP1) {
							display_popup_msg("not allowed select !!");
						} else 
						#endif
						{
							char *vars = mx100_set_vars_toggle("cdmalink");				
							display_popup_msg("Enable CDMA PC Link => %s",vars);
							
						}
					}

					else if((int)cur_menu == (int)MENU_NO_STOP_BOOT) {
						char *vars;
//						clear_screen();
						vars = mx100_set_vars_toggle("bootcharge");				
						display_popup_msg("Charge on boot => %s",vars);
		
						//clear_screen();
					}

					else if((int)cur_menu == (int)MENU_ENABLE_SYSTEM_LOG) {
						char *vars;
//						clear_screen();
						vars = mx100_set_vars_toggle("systemlog");				
						display_popup_msg("Charge systemlog => %s",vars);
		
						//clear_screen();
					}
					else if((int)cur_menu == (int)MENU_ENABLE_OLD_8000_TS) {
						char *vars;
//						clear_screen();
						vars = mx100_set_vars_toggle("old8000ts");				
						display_popup_msg("Use melfas OLD 8000 Touch screen=>%s",vars);

						//clear_screen();
					}
		
					break;
				case	KEY_VOLUMEUP: 
					if(g_cur_menu>0) g_cur_menu--;

					cur_menu =g_menu_str[ g_cur_menu];
					if(cur_menu[0]=='-') g_cur_menu--;
					
					break;
				case KEY_VOLUMEDOWN:
					if(g_cur_menu< g_max_menu-1) g_cur_menu++;

					cur_menu =g_menu_str[ g_cur_menu];
					if(cur_menu[0]=='-') g_cur_menu++;
					break;

				#if (MX100_HW_VER == MX100_EVM1)
				case  KEY_BACK:					break;
				case  KEY_MENU:				break;
				case  KEY_HOME:					break;		
				#endif
			}

			display_menu();
		}
	}

	ExitLoop:
	;	
}


// 2011.03.24 JHLIM
// MX100 boot menu settings IMPL.
//
char* mx100_get_vars(char *name)
{
char *get_value = NULL;

	get_value = getenv (name);
	if (get_value) {

	} else {
		if(strcmp(name,"bootcharge") == 0) {
			get_value ="on";
		}
		else if(strcmp(name,"uart2debug") == 0) {
			if(g_mx100_hw_type>=MX100_TP1) {
				get_value="off";
			} else {
				get_value="on";
			}
		}
		else if(strcmp(name,"cdmalink") == 0) {
			#if (MP_MODE_DEFAULT == MP_MODE_PROCESS)
			get_value = "on";
			#else
			get_value = "off";
			#endif
		}
		else if(strcmp(name,"old8000ts") == 0) {
			get_value = "off";
		} 
		else if(strcmp(name,"systemlog") == 0) {
			get_value = "off";
		} 
		else if(strcmp(name,"mpmode") == 0) {
			#if (MP_MODE_DEFAULT == MP_MODE_PROCESS)
			get_value = "process";
			#else
			get_value = "normal";
			#endif
		} 
		else if(strcmp(name,"mx100_hw") == 0) {
			get_value = get_mx100_hw_name();
		} 
		else {
			get_value = "none";
		}
		setenv(name,get_value);
	}
	return get_value;
}

void mx100_set_vars(char *name,char *value)
{
	setenv(name,value);
	mx100_save_boot_args();
}

char * mx100_set_vars_toggle(char *name)
{
	static char vars[8];
	
	strcpy(vars,mx100_get_vars(name));

	if(strcmp(name,"mpmode") == 0) {
		if(strcmp(vars,"normal") == 0) {
			strcpy(vars,"process");
		} else {
			strcpy(vars, "normal");
		}
	} else {
		if(strcmp(vars,"on") == 0) {
			strcpy(vars,"off");
		} else {
			strcpy(vars, "on");
		}
	}
	
	mx100_set_vars(name,vars);

	mx100_save_boot_args();

	if(vars)	return vars;
	else return "ng";
}

void mx100_save_boot_args(void)
{
	char bootargs[256];
	char *uart2debug =  mx100_get_vars("uart2debug");
	char *uart2console;

//#if 0 // ktj_sleep_crash
//	uart2console = "ttySAC2";
//#else
	if(strcmp(uart2debug,"on") ==0) {
		uart2console = "ttySAC2";
	} else {
		uart2console = "null";
	}
//#endif
	
	sprintf(bootargs,"setenv bootargs console=%s,115200 init=/linuxrc "
		" uart2debug=%s"
		" cdmalink=%s"
		" old8000ts=%s"
		" mpmode=%s"
		" systemlog=%s"
		" mx100_hw=%s",
		uart2console,
	uart2debug,
	mx100_get_vars("cdmalink"),
	mx100_get_vars("old8000ts"),
	mx100_get_vars("mpmode"),
	mx100_get_vars("systemlog"),
	mx100_get_vars("mx100_hw")
	);	
	
	run_command(bootargs,0);
	run_command("save'",0);
}

void mx100_init_boot_args(void)
{
	char *get_value = NULL;
	get_value = getenv ("bootargs");
	if(!get_value) {
		mx100_save_boot_args();
	}

	#ifdef ENABLE_CDMA_SELECT_BY_FILE
	{
		char *buffer;
		int filesize;
		int file_exist;
		file_exist = read_from_movinand("/cdma_link.bin",&buffer,&filesize);

		if(file_exist) {
			mx100_set_vars("cdmalink","on");
		} else {
			mx100_set_vars("cdmalink","off");
		}
		mx100_save_boot_args();
	}
	#endif
}

//
// mx100 main boot routine( charge, key check, sd copy etc)
//
extern int check_routine(void); /* ktj */

int g_mx100_hw_type;

char *get_mx100_hw_name(void)
{
	static char g_mx100_hw_name[16];

	switch(g_mx100_hw_type) {
		case MX100_ES1:
		case MX100_ES2: strcpy(g_mx100_hw_name,"ES"); break;
		case MX100_TP1: strcpy(g_mx100_hw_name,"TP"); break;	
		case MX100_LPP: strcpy(g_mx100_hw_name,"LPP"); break;
		default: strcpy(g_mx100_hw_name,"UNKNOWN"); break;
	}
	printf("mx100_hw : %s \n",g_mx100_hw_name);
	return g_mx100_hw_name;
}

static int g_bootmenu_mode = MX100_BOOTMENU_USER_EMERGENCY;


int check_bootmenu_mode(void)
{
	char *mx100_sys_data;
	int file_size;
	int enter_bootmenu = 0;
	
	#if (MP_MODE_DEFAULT== MP_MODE_PROCESS) 
		/*
	if(mx100_boot_from()==BOOT_MMCSD) {
		g_bootmenu_mode = MX100_BOOTMENU_MP_PROCESS;
		printf("bootmenu mode :process\n");
	
		} 
		*/
		if(g_user_emergency_mode==_EMERGENCY_ENTER) {
			g_bootmenu_mode = MX100_BOOTMENU_MP_PROCESS;
			enter_bootmenu = 1;
		}
	#elif( MP_MODE_DEFAULT== MP_MODE_NORMAL) 
		#ifdef  SELECT_BOOTMENU_BY_SD

		if(g_user_emergency_mode==_EMERGENCY_ENTER) {
			if(read_from_sd("mx100.sys",&mx100_sys_data,&file_size) == 0) {  
				g_bootmenu_mode = MX100_BOOTMENU_USER_EMERGENCY;
				enter_bootmenu = 1;			
			} else {
				printf("bootmenu mode : %X \n",CHECK_ID2(mx100_sys_data));
				if(file_size>16 && CHECK_ID2(mx100_sys_data)== BOOT_MENU_MAGIC_ID) {
					printf("bootmenu mode : developer\n");
					g_bootmenu_mode = MX100_BOOTMENU_MP_NORMAL;
					enter_bootmenu= 1;
				} else {
					g_bootmenu_mode = MX100_BOOTMENU_NONE;
					enter_bootmenu = 0;	
				}
			}
		}
	
		#else
		if(g_user_emergency_mode==_EMERGENCY_ENTER) {
			g_bootmenu_mode = MX100_BOOTMENU_MP_NORMAL;
			enter_bootmenu= 1;
		}
		#endif
	#else
		if(g_user_emergency_mode==_EMERGENCY_ENTER) {
			g_bootmenu_mode = MX100_BOOTMENU_DEVELOPER;
			enter_bootmenu= 1;
		}
	#endif
	return enter_bootmenu;
}

int get_bootmenu_mode(void)
{
	return g_bootmenu_mode;
}

void mx100_pre_init(void)
{
	GPIO_Init();        

	mx100_gpio_preset();
	
	mx100_keypad_init();
}

int mx100_check_emergency_mode(void)
{
	int i,power_key,vol_minus_key;
	int power_key_first,vol_minus_key_first;
	int detect_time = 35;
	
	g_user_emergency_mode = _EMERGENCY_NONE;

	power_key_first= GPIO_GetDataEach(U_GPIO_POWER_KEY_IN);
	vol_minus_key_first = GPIO_GetDataEach(U_GPIO_VOLMINUS_KEY_IN);
	mx100_mdelay(100);
	#if (MP_MODE_DEFAULT== MP_MODE_PROCESS) 
	detect_time = 5;
	#else
	detect_time = 35;
	#endif
	
	for(i=0;i<detect_time;i++) {
		power_key= GPIO_GetDataEach(U_GPIO_POWER_KEY_IN);
		vol_minus_key = GPIO_GetDataEach(U_GPIO_VOLMINUS_KEY_IN);
		//printf("%d %d\n",power_key,vol_minus_key);
		
		if(power_key==1 || vol_minus_key==1) {
			if(vol_minus_key_first == 0) {
				printf("emergency trying...stoped\n");
				g_user_emergency_mode = _EMERGENCY_TRY;
			} else {
				printf("emergency canceld...\n");
				g_user_emergency_mode = _EMERGENCY_NONE;	
			}
			return 0;
		}
		mx100_mdelay(100);
	}		

	printf("emergency entered...\n");
	g_user_emergency_mode = _EMERGENCY_ENTER;
	return 1;
}
void mx100_sys_entry(void)
{
	unsigned int rst_status;

/* move to mx100_pre_init()  */
//	GPIO_Init();        

//	mx100_gpio_preset();
	
//	mx100_keypad_init();  

/* 2011.04.28 JHLIM  avoid power long key detect when reboot.
Reset Control Register (RST_STAT, R/W, Address = 0xE010_A000)

RESERVED[31:20]
DIDLE_WAKEUP[19]
DSTOP_WAKEUP[18]
Reserved[17]
SLEEP_WAKEUP[16]
Reserved[15:4]
SWRESET[3]
nWDTRESET[2]
nWRESET[1]
nRESET[0]
*/
	rst_status = Inp32(0xE010A000);  
	printf("rst_stat:%x\n",rst_status);

	if(GPIO_GetDataEach(U_GPIO_POWER_KEY_IN)==1 && 
		!(rst_status & (0x4))/*  &&
		is_pressed_hw_reset() ==0   disable 2011.06.03 for fix reboot limitless */ 
	) {
		/* 2011.04.26  power on when power key pressed long */
		/* 2011.05.11  when HW RESET skip the check power long key*/
		power_off();
	} else {

		mx100_check_emergency_mode();

		if(g_user_emergency_mode == _EMERGENCY_TRY) {
			power_off();
		}
		
		printf("power key pressed\n");
	}
		
	#ifdef DETECT_MX100_HW	
	ADCTS_Init();
	g_mx100_hw_type = get_mx100_hw_type();
	mx100_init_boot_args();
	#endif	

	init_mx100_ui((unsigned char*)CFG_LCD_FBUFFER);

    	check_routine(); /* ktj check lowbattery */

	#ifdef DISPLAY_VERSION_INFO	
	draw_mx100_version();
	#endif

#ifdef ENABLE_CHARGE_ROUTINE
	#ifdef ENABLE_NO_STOP_BOOT
	if( strcmp(mx100_get_vars("bootcharge"),"on") == 0) {
		if(!(rst_status & (0x4)))  {
			charge_routine();  
		}
	}
	#else
	charge_routine();  // battery charge loop.
	#endif
#endif

	#ifdef DISPLAY_BOOTLOGO
	draw_bootlogo();
	#endif

	#ifdef ENABLE_BOOT_MENU
	mx100_boot_menu();
	#endif
}

